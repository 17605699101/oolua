#labels Featured
OOLua Binding Framework Cheat Sheet
<wiki:toc max_depth="3" />

= Creating a proxy for a class =
== No functions of interest for Lua ==
{{{
struct foo{};

OOLUA_CLASS_NO_BASES(foo)//class has no bases
    OOLUA_NO_TYPEDEFS
OOLUA_CLASS_END
}}}

Then in a source file expose the class telling framework that the instance has no functions of interest and providing the name it will be identified by in Lua code(foo).
{{{
EXPORT_OOLUA_NO_FUNCTIONS(foo)
}}}

== Has a member function which takes no parameters == 
{{{
struct foo
{
  int bar();
};

OOLUA_CLASS_NO_BASES(foo)//class has no bases
    OOLUA_NO_TYPEDEFS
    OOLUA_MEM_FUN_0(int,bar)
OOLUA_CLASS_END
}}}

The line "OOLUA_MEM_FUN_0(int,bar)" tells the binding that the function takes no parameters, returns an int and the functions name is bar.

Then in a source file expose the class telling the framework that the instance has a function of interest yet no constant member functions, also providing the name it will be identified by in Lua code(foo).
{{{
EXPORT_OOLUA_FUNCTIONS_1_NON_CONST(foo /*name of class*/
                                  ,bar)/*function being exposed*/
EXPORT_OOLUA_FUNCTIONS_0_CONST(foo)
}}}

== Abstract class ==
{{{
struct foo
{
  int bar() = 0;
};

OOLUA_CLASS_NO_BASES(foo)//class has no bases
    OOLUA_TYPEDEFS Abstract OOLUA_END_TYPES/*tell the framework it is abstract*/
    OOLUA_MEM_FUN_0(int,bar)
OOLUA_CLASS_END
}}}

{{{
EXPORT_OOLUA_FUNCTIONS_1_NON_CONST(foo /*name of class*/
                                  ,bar)/*function being exposed*/
EXPORT_OOLUA_FUNCTIONS_0_CONST(foo)
}}}

== Derived class ==
Expanding on the example in [CheatSheet#Abstract_class]
{{{
struct baz
{
  int bar(){return 1};
};

OOLUA_CLASS(baz) : public Proxy_class<foo>
    OOLUA_BASIC
    OOLUA_NO_TYPEDEFS
    OOLUA_BASES_START foo OOLUA_BASES_END
OOLUA_CLASS_END
}}}
{{{
EXPORT_OOLUA_NO_FUNCTIONS(baz)
}}}

OOLUA_BASIC defines the basic functionality which a proxy class requires, this is automatically added when not using "OOLUA_CLASS". You can see that the base class functions which have already been exposed do not need to be re-exposed and they will be available for this type.<br />
{{{
OOLUA_BASES_START foo OOLUA_BASES_END
}}}
This line tells the binding about the hierarchy again this is automatically added when not using "OOLUA_CLASS".

==OOLUA::Script==
OOLua is purposely designed not to be dependant on the class OOLUA::Script and therefore passes around it's dependency of a lua_State. OOLUA::Script is a helper class to easy use, it scopes a lua_State and provides methods to register types, an instance to call Lua functions and functions for a little state management.

==Usage without OOLUA::Script==
To use the binding without this class and providing your own or 3rd party instance of lua_State, requires a call to a setup method. This method adds the necessary tables and globals for it to work with the binding.
{{{
void setup_user_lua_state(lua_State* l);
}}}
