#labels Featured
OOLua Binding Framework Cheat Sheet
<wiki:toc max_depth="3" />

= Creating a proxy for a class =
== No functions of interest for Lua ==
{{{
struct foo{};

OOLUA_CLASS_NO_BASES(foo)//class has no bases
    OOLUA_NO_TYPEDEFS
OOLUA_CLASS_END
}}}

Then in a source file expose the class telling framework that the instance has no functions of interest and providing the name it will be identified by in Lua code(foo).
{{{
EXPORT_OOLUA_NO_FUNCTIONS(foo)
}}}

== Has a member function which takes no parameters == 
{{{
struct foo
{
  int bar();
};

OOLUA_CLASS_NO_BASES(foo)//class has no bases
    OOLUA_NO_TYPEDEFS
    OOLUA_MEM_FUN_0(int,bar)
OOLUA_CLASS_END
}}}

The line "OOLUA_MEM_FUN_0(int,bar)" tells the binding that the function takes no parameters, returns an int and the functions name is bar.

Then in a source file expose the class telling the framework that the instance has a function of interest yet no constant member functions, also providing the name it will be identified by in Lua code(foo).
{{{
EXPORT_OOLUA_FUNCTIONS_1_NON_CONST(foo /*name of class*/
                                  ,bar)/*function being exposed*/
EXPORT_OOLUA_FUNCTIONS_0_CONST(foo)
}}}

== Abstract class ==
{{{
struct foo
{
  int bar() = 0;
};

OOLUA_CLASS_NO_BASES(foo)//class has no bases
    OOLUA_TYPEDEFS Abstract OOLUA_END_TYPES/*tell the framework it is abstract*/
    OOLUA_MEM_FUN_0(int,bar)
OOLUA_CLASS_END
}}}

{{{
EXPORT_OOLUA_FUNCTIONS_1_NON_CONST(foo /*name of class*/
                                  ,bar)/*function being exposed*/
EXPORT_OOLUA_FUNCTIONS_0_CONST(foo)
}}}

== Derived class ==
Expanding on the example in [CheatSheet#Abstract_class]
{{{
struct baz
{
  int bar(){return 1};
};

OOLUA_CLASS(baz) : public Proxy_class<foo>
    OOLUA_BASIC
    OOLUA_NO_TYPEDEFS
    OOLUA_BASES_START foo OOLUA_BASES_END
OOLUA_CLASS_END
}}}
{{{
EXPORT_OOLUA_NO_FUNCTIONS(baz)
}}}

OOLUA_BASIC defines the basic functionality which a proxy class requires, this is automatically added when not using "OOLUA_CLASS". You can see that the base class functions which have already been exposed do not need to be re-exposed and they will be available for this type.<br />
{{{
OOLUA_BASES_START foo OOLUA_BASES_END
}}}
This line tells the binding about the hierarchy again this is automatically added when not using "OOLUA_CLASS".

=Parameter Traits=
Traits are used two fold.
Where the following are used exclusively for bound member functions:
 * in_p  *Parameter is only passed to the real member function.*
 * out_p  *Parameter or a function return is passed back to Lua.*
 * in_out_p  *Parameter is passed to function and also back to Lua.*
And the following used for member functions and also pushing and pulling to and from the Lua stack:
 * cpp_in_p  *C++ code takes ownership of a pointer.*
 * cpp_out_p  *Lua takes ownership of a pointer.*

If parameter traits are not defined then it defaults to OOLUA::in_p.
For function return values OOLUA::out_p is used (inside the generating
function), this template is specialised for void types.

=lua_State=
==OOLUA::Script==
OOLua is purposely designed not to be dependant on the class OOLUA::Script and therefore passes around it's dependency of a lua_State. OOLUA::Script is a helper class to easy use, it scopes a lua_State and provides methods to register types, an instance to call Lua functions and functions for a little state management.

==Usage without OOLUA::Script==
To use the binding without this class and providing your own or 3rd party instance of lua_State, requires a call to a setup method. This method adds the necessary tables and globals for it to work with the binding.
{{{
void setup_user_lua_state(lua_State* l);
}}}

=Registering a class type with a lua_State=
As mentioned Script is only a helper class, so internally it's register function is the same as without.
==With OOLUA::Script==
{{{
OOLUA::Script s;
s.register_class<Foo>();
}}}
or
{{{
OOLUA::Script s;
Foo* f;
s.register_class(f);
}}}
==With a lua_State==
{{{
extern lua_State* s;
OOLUA::register_class<Foo>(s);
}}}

=Calling a Lua function=
A Lua function can be called using [http://code.google.com/p/oolua/source/browse/trunk/include/lua_function.h Lua_function], of which there is already bound instance available in OOLUA::Script. The method can be called via it's name or via a Lua_ref_func pulled from lua.
==Via name==
{{{
func = function() end
}}}
{{{
OOLUA::Script s;
s.call("func");
}}}
==Via reference==
This example assumes that an function is at the top on the Lua stack.
{{{
OOLUA::Script s;
OOLUA::Lua_ref_func f;
OOLUA::pull2cpp(s,f);
s.call(f);
}}}


