OOLua Binding Framework Cheat Sheet 
<wiki:toc max_depth="4" />

== Constructors ==
1.3 version of the library adds partial support for constructors, for this the ABI is broken and three new types have been added to oolua_typedefs.h which can be included inside the OOLUA_TYPEDEFS macros.
||*Type*||*Meaning*||
||No_default_constructor||There is not a default constructor in the public interface yet there are other constructors.||
||No_public_constructors||There are no constructors in the public interface.||
||No_public_destructor||There is not a destructor in the public interface and OOLua will not attempt to delete an instance of this type||

If the type No_public_constructors is not present in the classes Typedefs then OOLua requires to be told about constructors between the macros OOLUA_CONSTRUCTORS_BEGIN and OOLUA_CONSTRUCTORS_END. For convenience instead of using the previous two macros with no further constructors, a helper macro is defined OOLUA_ONLY_DEFAULT_CONSTRUCTOR.

See [http://code.google.com/p/oolua/source/browse/trunk/unit_tests/bind_classes/expose_class_constructors.h expose_class_constructors.h] and [http://code.google.com/p/oolua/source/browse/trunk/unit_tests/cpp_classes/cpp_constructor_mock.h cpp_constructor_mock.h] and [http://code.google.com/p/oolua/source/browse/trunk/unit_tests/test_classes/construct.cpp construct.cpp]
 

== Portable ==
=== Creating a proxy for a class ===

==== No functions of interest for Lua ====
{{{
struct foo{};

OOLUA_CLASS_NO_BASES(foo)//class has no bases
    OOLUA_NO_TYPEDEFS
    OOLUA_ONLY_DEFAULT_CONSTRUCTOR
OOLUA_CLASS_END
}}}

Then in a source file expose the class telling framework that the instance has no functions of interest and providing the name it will be identified by in Lua code(foo).
{{{
EXPORT_OOLUA_NO_FUNCTIONS(foo)
}}}

==== Has a member function which takes no parameters ====
{{{
struct foo
{
  int bar();
};

OOLUA_CLASS_NO_BASES(foo)//class has no bases
    OOLUA_NO_TYPEDEFS
    OOLUA_ONLY_DEFAULT_CONSTRUCTOR
    OOLUA_MEM_FUNC_0(int,bar)
OOLUA_CLASS_END
}}}

The line "OOLUA_MEM_FUNC_0(int,bar)" tells the binding that the function takes no parameters, returns an int and the functions name is bar.

Then in a source file expose the class telling the framework that the instance has a function of interest yet no constant member functions, also providing the name it will be identified by in Lua code(foo).
{{{
EXPORT_OOLUA_FUNCTIONS_1_NON_CONST(foo /*name of class*/
                                  ,bar)/*function being exposed*/
EXPORT_OOLUA_FUNCTIONS_0_CONST(foo)
}}}

==== Has a member function which takes one parameter ====
{{{
struct foo
{
  int bar(float);
};

OOLUA_CLASS_NO_BASES(foo)
    OOLUA_NO_TYPEDEFS
    OOLUA_ONLY_DEFAULT_CONSTRUCTOR
    OOLUA_MEM_FUNC_1(int/*return type*/
                   ,bar/*function name*/
                   ,float)/*parameter type*/
OOLUA_CLASS_END
}}}

{{{
EXPORT_OOLUA_FUNCTIONS_1_NON_CONST(foo,bar)
EXPORT_OOLUA_FUNCTIONS_0_CONST(foo)
}}}

==== Abstract class ====
{{{
struct foo
{
  int bar() = 0;
};

OOLUA_CLASS_NO_BASES(foo)//class has no bases
    OOLUA_TYPEDEFS Abstract OOLUA_END_TYPES/*tell the framework it is abstract*/
    OOLUA_MEM_FUNC_0(int,bar)
OOLUA_CLASS_END
}}}

{{{
EXPORT_OOLUA_FUNCTIONS_1_NON_CONST(foo /*name of class*/
                                  ,bar)/*function being exposed*/
EXPORT_OOLUA_FUNCTIONS_0_CONST(foo)
}}}

==== Derived class ====
Expanding on the example in [CheatSheet#Abstract_class]
{{{
struct baz : foo
{
  int bar(){return 1};
};

OOLUA_CLASS(baz) : public Proxy_class<foo>
    OOLUA_BASIC
    OOLUA_NO_TYPEDEFS
    OOLUA_BASES_START foo OOLUA_BASES_END
    OOLUA_ONLY_DEFAULT_CONSTRUCTOR
OOLUA_CLASS_END
}}}
{{{
EXPORT_OOLUA_NO_FUNCTIONS(baz)
}}}

OOLUA_BASIC defines the basic functionality which a proxy class requires, this is automatically added when not using "OOLUA_CLASS". You can see that the base class functions which have already been exposed do not need to be re-exposed and they will be available for this type.<br />
{{{
OOLUA_BASES_START foo OOLUA_BASES_END
}}}
This line tells the binding about the hierarchy again this is automatically added when not using "OOLUA_CLASS".

=== Class operators ===
Class operators are exposed between the OOLUA_TYPEDEFS_START and OOLUA_TYPEDEFS_END set of macros. The following is a list of the supported operators.
||OOLua type||C++ and Lua operator||
||Less_op|| <||
||Equal_op||==||
||Not_equal_op|| !=, not ==||
||Less_equal_op||<= Note: Greater than comes for free||
||Div_op||/||
||Mul_op||{{{*}}}||
||Sub_op||-||
||Add_op||+||

See [http://code.google.com/p/oolua/source/browse/trunk/unit_tests/cpp_classes/cpp_class_ops.h cpp_class_ops.h], [http://code.google.com/p/oolua/source/browse/trunk/unit_tests/bind_classes/lua_class_ops.h lua_class_ops.h] and [http://code.google.com/p/oolua/source/browse/trunk/unit_tests/test_classes/operators.cpp operators.cpp]
=== Parameter type traits ===
Traits are used two fold.
Where the following are used exclusively for bound member functions:
 * in_p  *Parameter is only passed to the real member function.*
 * out_p  *Parameter or a function return is only passed back to Lua.*
 * in_out_p  *Parameter is passed to function and also back to Lua.*
And the following used for member functions and also pushing and pulling to and from the Lua stack:
 * cpp_in_p  *C++ code takes ownership of a pointer.*
 * cpp_out_p  *Lua takes ownership of a pointer.*

If parameter traits are not defined then it defaults to OOLUA::in_p.
For function return values OOLUA::out_p is used (inside the generating
function), this template is specialised for void types.

See [http://code.google.com/p/oolua/source/browse/trunk/unit_tests/cpp_classes/cpp_out_params.h cpp_out_params.h], [http://code.google.com/p/oolua/source/browse/trunk/unit_tests/bind_classes/expose_out_params.h expose_out_params.h] and [http://code.google.com/p/oolua/source/browse/trunk/unit_tests/test_classes/out_params.cpp out_params.cpp]

=== Registering static or C Functions ===
=== Registering a proxy class ===
=== Pushing values to Lua ===
=== Pulling values from Lua ===
=== Lua references ===
=== Lua Tables ===
=== Calling Lua functions ===




== Platform supports __VA_ARGS__ ==
If the platform in use supports variadic macros then in most cases a generic macro can be used as follows, unless the portable macro would have contained a 0 (zero).
=== Exporting functions ===
{{{
EXPORT_OOLUA_FUNCTIONS_NON_CONST(foo /*name of class*/
                                  ,bar/*function being exposed*/
                                  ,baz)/*function being exposed*/
EXPORT_OOLUA_FUNCTIONS_0_CONST(foo)
}}}

=== Proxying functions ===
=== Proxying C and static functions ===
=== Proxying classes with bases ===
{{{
struct baz : foo
{
};

OOLUA_PROXY_CLASS(baz,foo)
    OOLUA_NO_TYPEDEFS
    OOLUA_ONLY_DEFAULT_CONSTRUCTOR
OOLUA_CLASS_END
}}}
=== Member functions with and without parameters ===
{{{
struct foo
{
  int bar();
  void baz(int );
};

OOLUA_PROXY_CLASS(foo)
    OOLUA_NO_TYPEDEFS
    OOLUA_ONLY_DEFAULT_CONSTRUCTOR
    OOLUA_MEM_FUNC_0(int,bar)
    OOLUA_MEM_FUNC(int,baz,int)
OOLUA_CLASS_END
}}}
If a function has no parameters then the macro OOLUA_MEM_FUNC_0 or one of its variants is required. On the other hand if it has one or more then the varadic macro OOLUA_MEM_FUNC can be used.
== Platform is g++ or mscv ==
These platforms support __VA_ARGS__ and also a comma deletion extension which enables suffixes of "0" to be removed from macros registered.
Registering classes with and without bases using the same macro OOLUA_PROXY_CLASS 

{{{
struct foo{};

OOLUA_PROXY_CLASS(foo)//class has no bases
    OOLUA_NO_TYPEDEFS
    OOLUA_ONLY_DEFAULT_CONSTRUCTOR
OOLUA_CLASS_END
}}}

{{{
struct foo
{
  int bar();
  void baz(int );
};

OOLUA_PROXY_CLASS(foo)//class has no bases
    OOLUA_NO_TYPEDEFS
    OOLUA_ONLY_DEFAULT_CONSTRUCTOR
    OOLUA_MEM_FUNC(int,bar)
    OOLUA_MEM_FUNC(int,bar,int)
OOLUA_CLASS_END
}}}