OOLua Binding Framework speed compared to other bindings.
<wiki:toc max_depth="4" />

= Introduction =
For these profile tests the following libraries were used:
 * Luabind 0.8.1 (Using the defines LUABIND_NO_ERROR_CHECKING and LUABIND_DONT_COPY_STRINGS)
 * OOLUA 1.2
 * Swig 1.3.40

==Setting and getting ==
Getting and setting a member variable via a member function.
C++ code
{{{
class Set_get
{
public:
	Set_get():_i(0.0){}
	void set(double i)
	{
		_i = i;
	}
	double get()const
	{
		return _i;
	}
private:
	double _i;
};
}}}

Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_set_and_get.lua in the profile directory; yet the construction is not part of the profile test.
{{{
local N = 10
local ave = 0
local times = 1000000
for i = 0, N do
	local obj = Set_get:new()

	local t0 = os.clock()
	for i=1,times do
		obj:set(i)
		if(obj:get() ~= i)then
			error("failed")
		end
	end
	local dt = os.clock()-t0
	if i~=0 then
	 ave = ave + dt
	end
end

print('OOLua access (average elapsed time):',ave/N)
}}}
===Access results===
|| *Library* || *Time(sec)* ||
||OOLua||0.7203||
||Swig||1.4453||
||Luabind||2.7438||

==Class exchanging==
The following tests use a class hierarchy as detailed below:
{{{
class ProfileBase
{
public:
	ProfileBase():_i(0){}
	virtual ~ProfileBase(){}
	void increment_a_base(ProfileBase* base)
	{
		++base->_i;
	}
	virtual void virtual_func()
	{
		++_i;
	}
	virtual void pure_virtual_func() = 0;
private:
	int _i;
};

class ProfileAnotherBase
{
public:
	virtual ~ProfileAnotherBase(){}
};
class ProfileDerived : public ProfileBase
{
public:
	virtual ~ProfileDerived(){}
	virtual void pure_virtual_func()
	{
		++_i;
	}
private:
	int _i;
};

class ProfileMultiBases : public ProfileDerived, public ProfileAnotherBase
{
public:
	void virtual_func()
	{
		++_i;
	}
private:
	int _i;
};
}}}

===Passing a derived class in Lua to a C++ member class that wants a base ===
Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_derived.lua in the profile directory; yet the construction is not part of the profile test.
{{{
local N = 10
local ave = 0
local times = 1000000

for i = 0, N do
	local obj = ProfileDerived:new()
	local increment_me = ProfileDerived:new()

	local t0 = os.clock()
	for i=1,times do
		obj:increment_a_base(increment_me)
	end
	local dt = os.clock()-t0
	if i~=0 then
	 ave = ave + dt
	end
end

print('OOLua passing derived to a function that wants a base  (average elapsed time):',ave/N)
}}}

====Wants base results====
|| *Library* || *Time(sec)* ||
||Swig||0.7641||
||OOLua||0.8188||
||Luabind||2.1421||


===Passing a derived class which uses multiple inheritance in Lua to a C++ member class that wants a base ===
Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_derived.lua in the profile directory; yet the construction is not part of the profile test.
{{{
local N = 10
local ave = 0
local times = 1000000
for i = 0, N do
	local obj = ProfileDerived:new()
	local increment_me = ProfileMultiBases:new()

	local t0 = os.clock()
	for i=1,times do
		obj:increment_a_base(increment_me)
	end
	local dt = os.clock()-t0
	if i~=0 then
	 ave = ave + dt
	end
end

print('OOLua passing derived with multiple bases to a function that wants a base  (average elapsed time):',ave/N)
}}}

====Multiple inheritance wants base results====
|| *Library* || *Time(sec)* ||
||Swig||0.775||
||OOLua||0.7891||
||Luabind||2.3265||


The following test should give the same results per library, yet I wanted to check this.
===Calling a virtual function===
Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_derived.lua in the profile directory; yet the construction is not part of the profile test.
{{{
local N = 10
local ave = 0
local times = 1000000
for i = 0, N do
	local obj = ProfileMultiBases:new()

	local t0 = os.clock()
	for i=1,times do
		obj:virtual_func()
	end
	local dt = os.clock()-t0
	if i~=0 then
	 ave = ave + dt
	end
end

print('OOLua virtual function  (average elapsed time):',ave/N)
}}}


====Calling a virtual function results====
|| *Library* || *Time(sec)* ||
||OOLua||0.3125||
||Swig||0.6922||
||Luabind||1.5141||


===Calling a pure virtual function===
Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_derived.lua in the profile directory; yet the construction is not part of the profile test.
{{{
local N = 10
local ave = 0
local times = 1000000
for i = 0, N do
	local obj = ProfileMultiBases:new()

	local t0 = os.clock()
	for i=1,times do
		obj:pure_virtual_func()
	end
	local dt = os.clock()-t0
	if i~=0 then
	 ave = ave + dt
	end
end

print('OOLua pure virtual function  (average elapsed time):',ave/N)
}}}

====Calling a pure virtual function results====
|| *Library* || *Time(sec)* ||
||OOLua||0.3203||
||Swig||0.6828||
||Luabind||1.5157||


===Calling a pure virtual function on an instance passed to Lua===
Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_derived.lua in the profile directory; yet the construction is not part of the profile test.
{{{
func = function(obj)
local N = 10
local ave = 0
local times = 1000000
	for i = 0, N do
		local t0 = os.clock()
		for i=1,times do
			obj:pure_virtual_func()
		end
		local dt = os.clock()-t0
		if i~=0 then
		 ave = ave + dt
		end
	end
	return ave/N
end
}}}
====Calling a virtual function in a function results====
|| *Library* || *Time(sec)* ||
||OOLua||0.3156||
||Swig||0.6843||
||Luabind||1.1328||