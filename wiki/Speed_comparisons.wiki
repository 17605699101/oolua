#labels Featured
OOLua Binding Framework speed compared to other bindings.
<wiki:toc max_depth="4" />

= Introduction =
For these profile tests the following libraries were used:
 * Luabind 0.9.1 *Note*: There is no official version which supports Lua 5.2 so instead the following version was used: [http://github.com/ThomasNelson/luabind/tree/TomN-Lua52%2Bfactories%2Bstl Thomas Nelson's fork]  <br />Using the defines LUABIND_NO_ERROR_CHECKING and LUABIND_DONT_COPY_STRINGS and Boost 1.4.0
 * OOLua 1.4 Using defines OOLUA_RUNTIME_CHECKS_ENABLED == 1 OOLUA_CHECK_EVERY_USERDATA_IS_CREATED_BY_OOLUA == 1, OOLUA_USERDATA_OPTIMISATION ==1
  Times also shown when using OOLUA_RUNTIME_CHECKS_ENABLED ==  0 
 * Swig 2.0.1

Using a machine with the following CPU
{{{
Intel(R) Core(TM)2 Duo CPU     P7550  @ 2.26GHz
}}}

==Setting and getting ==
Getting and setting a member variable via a member function.
C++ code
{{{
class Set_get
{
public:
	Set_get():_i(0.0){}
	void set(double i)
	{
		_i = i;
	}
	double get()const
	{
		return _i;
	}
private:
	double _i;
};
}}}

Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_set_and_get.lua in the profile directory; yet the construction is not part of the profile test.
{{{
local N = 10
local ave = 0
local times = 1000000
for i = 0, N do
	local obj = Set_get:new()

	local t0 = os.clock()
	for i=1,times do
		obj:set(i)
		if(obj:get() ~= i)then
			error("failed")
		end
	end
	local dt = os.clock()-t0
	if i~=0 then
	 ave = ave + dt
	end
end

print('OOLua access (average elapsed time):',ave/N)
}}}
===Access results===
|| *Library* || *Time(sec)*  ||
|| || Lua 5.1 || Lua 5.2 || LuaJIT2 ||
||OOLua||0.3590224||0.3359856||0.2700227||
||Luabind||0.5077312||0.5134535||0.3928163||
||SWIG||0.7512369||0.7709426||0.5926358||
||OOLua no runtime checks||0.3018826||0.3009695||0.2411604||



==Class exchanging==
The following tests use a class hierarchy as detailed below:
{{{
class ProfileBase
{
public:
	ProfileBase():_i(0){}
	virtual ~ProfileBase(){}
	void increment_a_base(ProfileBase* base)
	{
		++base->_i;
	}
	virtual void virtual_func()
	{
		++_i;
	}
	virtual void pure_virtual_func() = 0;
private:
	int _i;
};

class ProfileAnotherBase
{
public:
	virtual ~ProfileAnotherBase(){}
};
class ProfileDerived : public ProfileBase
{
public:
	virtual ~ProfileDerived(){}
	virtual void pure_virtual_func()
	{
		++_i;
	}
private:
	int _i;
};

class ProfileMultiBases : public ProfileDerived, public ProfileAnotherBase
{
public:
	void virtual_func()
	{
		++_i;
	}
private:
	int _i;
};
}}}

===Passing a derived class in Lua to a C++ member class that wants a base ===
Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_derived.lua in the profile directory; yet the construction is not part of the profile test.
{{{
local N = 10
local ave = 0
local times = 1000000

for i = 0, N do
	local obj = ProfileDerived:new()
	local increment_me = ProfileDerived:new()

	local t0 = os.clock()
	for i=1,times do
		obj:increment_a_base(increment_me)
	end
	local dt = os.clock()-t0
	if i~=0 then
	 ave = ave + dt
	end
end

print('OOLua passing derived to a function that wants a base  (average elapsed time):',ave/N)
}}}

====Wants base results====
|| *Library* || *Time(sec)* || ||
|| || Lua 5.1 || Lua 5.2 || LuaJIT2 ||
||OOLua||0.1925849||0.196252||0.1694646||
||Luabind||0.3344658||0.3699374||0.3107969||
||SWIG||0.347758||0.3456323||0.2810876||
||OOLua no runtime checks||0.1772717||0.1947286||0.1425415||

===Passing a derived class which uses multiple inheritance in Lua to a C++ member class that wants a base ===
Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_derived.lua in the profile directory; yet the construction is not part of the profile test.
{{{
local N = 10
local ave = 0
local times = 1000000
for i = 0, N do
	local obj = ProfileDerived:new()
	local increment_me = ProfileMultiBases:new()

	local t0 = os.clock()
	for i=1,times do
		obj:increment_a_base(increment_me)
	end
	local dt = os.clock()-t0
	if i~=0 then
	 ave = ave + dt
	end
end

print('OOLua passing derived with multiple bases to a function that wants a base  (average elapsed time):',ave/N)
}}}

====Multiple inheritance wants base results====
|| *Library* || *Time(sec)*  || ||
|| || Lua 5.1 || Lua 5.2 || LuaJIT2 ||
||OOLua||0.2057114||0.2099513||0.1807507||
||Luabind||0.3404258||0.3745065||0.3139187||
||SWIG||0.3550647||0.3597586||0.3155249||
||OOLua no runtime checks||0.1852408||0.2143713||0.1622692||

The following test should give the same results per library, yet I wanted to check this.
===Calling a virtual function===
Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_derived.lua in the profile directory; yet the construction is not part of the profile test.
{{{
local N = 10
local ave = 0
local times = 1000000
for i = 0, N do
	local obj = ProfileMultiBases:new()

	local t0 = os.clock()
	for i=1,times do
		obj:virtual_func()
	end
	local dt = os.clock()-t0
	if i~=0 then
	 ave = ave + dt
	end
end

print('OOLua virtual function  (average elapsed time):',ave/N)
}}}


====Calling a virtual function results====
|| *Library* || *Time(sec)*  || ||
|| || Lua 5.1 || Lua 5.2 || LuaJIT2 ||
||OOLua||0.1298764||0.1328911||0.1081259||
||Luabind||0.2508799||0.2763377||0.2238482||
||SWIG||0.3185289||0.3184858||0.2458188||
||OOLua no runtime checks||0.1226391||0.1297259||0.0939919||

===Calling a pure virtual function===
Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_derived.lua in the profile directory; yet the construction is not part of the profile test.
{{{
local N = 10
local ave = 0
local times = 1000000
for i = 0, N do
	local obj = ProfileMultiBases:new()

	local t0 = os.clock()
	for i=1,times do
		obj:pure_virtual_func()
	end
	local dt = os.clock()-t0
	if i~=0 then
	 ave = ave + dt
	end
end

print('OOLua pure virtual function  (average elapsed time):',ave/N)
}}}

====Calling a pure virtual function results====
|| *Library* || *Time(sec)*  || ||
|| || Lua 5.1 || Lua 5.2 || LuaJIT2 ||
||OOLua||0.1318034||0.1328911||0.1088815||
||Luabind||0.2514496||0.2763377||0.2238482||
||SWIG||0.3195146||0.3221236||0.2461681||
||OOLua no runtime checks||0.1215891||0.1281504||0.0961552||

===Calling a pure virtual function on an instance passed to Lua===
Lua code <br />
Note: this code differs slightly in the construction of class instances for each framework see (library name)_derived.lua in the profile directory; yet the construction is not part of the profile test.
{{{
func = function(obj)
local N = 10
local ave = 0
local times = 1000000
	for i = 0, N do
		local t0 = os.clock()
		for i=1,times do
			obj:pure_virtual_func()
		end
		local dt = os.clock()-t0
		if i~=0 then
		 ave = ave + dt
		end
	end
	return ave/N
end
}}}
====Calling a virtual function in a function results====
|| *Library* || *Time(sec)* || ||
|| || Lua 5.1 || Lua 5.2 || LuaJIT2 ||
||OOLua||0.138073||0.129919||0.107684||
||Luabind||0.214728||0.228361||0.190358||
||SWIG||0.321698||0.319418||0.246192||
||OOLua no runtime checks||0.116942||0.130224||0.09406||